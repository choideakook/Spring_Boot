# 형 변환

## ✏️ 형 변환

### 📍 배경 지식 - 컴파일러

- Java 컴파일러는 코드를 실행해 볼 수 없다.
- 컴파일 과정에서 문법 검사 프로그램이 잘못된 문법을 그때그때 개발자에게 알려준다.
    - 즉시 문제가 발생한 원인과 위치, 교정방법 추천 서비스로 런타임 오류보다 교정하기 쉽다.

<br>

### 📍 형 변환의 조건

- 더 큰 타입 에서 더 작은 타입 으로 형 변환은 자동 변환된다.
    - 작은 타입 에서 더 큰 타이으로 형 변환은 불가능 하다.

```java
(o)
int a = 5;
double b = a;

//--------------//
(x)
double a = 5.0;
int b = a;
```

- ***형 변환의 원리***
    - 컴파일러는 코드를 실행해 볼 수 없기 때문에 변수에 어떤 숫자가 들어있는지 사전에 알 수 없다.
    - double 의 범위는 int 의 범위 보다 크고, 코드를 실행해 볼 수 없는 컴파일러 입장에선 어떤숫자가 들어올 지 알 수 없고,
    int 의 범위를 벗어나는 값이 들어올 경우 data 의 유실이 될 수 있어 애초에 컴파일 오류로 막아놓는다.
    - 반대로 int 의 모든 숫자는 double 로 표시할 수 있기 때문에 실행을 해보지않아도 가능하단 걸 알 수 있다.

<br>

### 📍 수동 형 변환 - 케스팅

- 작은 타입에서 큰 타입 으로,
혹은 완전히 다른 타입 으로 불가피하게 형 변환을 해야할 때가 있다.
    - 이 경우에서는 케스팅을 통해 강자로 형 변환을 할 수 있게 추가 코드를 입력할 수 있다.

```java
double a = 5.0;
int b = (int) a;
```

- String → int

```java
String a = "5";
int b = Integer.parseInt(a)
```

<br>

## ✏️ 상속 관계에서의 형 변환

- 상속관계 예제

```java
Class Human {
    void eat(){}
}

Class Sam extends Human{
    void sing(){}
}

Class Jay extends Human{
    void run(){}
}
```

- 상속관계에 있어서 더 큰 타입인 Human 은 작은 타입인 sam 이나 jat 로 변환할 수 없다.
    - 하지만 반대의 경우엔 변환할 수 있다.

```java
(o)
Human human = new Sam();

(x)
Sam sam = new Human();
Sam sam = new Jay();
```

- 컴파일러는 부모 객체를 기준으로 모든 기능을 온전히 상속받은 자식 객체로의 변환은 인정해 준다.
    - 하지만 자식 객체의 추가된 method 는 사용할 수 없게 된다.
- 반대로 method 가 추가된 자식 객체 기준으로 method 가 부족할 수도 있는 부모 객체는 컴파일러가 형 변환을 인정하지 않는다.
    - 부모 객체가 갖고있지 않은 method 가 호출될수도 있기 때문

### 📍 강제 형변환

- 경우에 따라 강제로 형변환이 가능하지만 임시 방편일 뿐이고,
코드상에 문제가 발생할경우 런타임 에러로 발생할 수 있어 안티코드에 가까운 방법은 이다.

```java
Sam sam = (Sam) Human();
```