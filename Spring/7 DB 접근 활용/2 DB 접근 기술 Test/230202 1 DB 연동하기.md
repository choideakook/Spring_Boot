# DB 연동하기

## ✏️ @SpringBootTest

Test Class 에 SpringBootTest 어노테이션이 있으면
application Class 의 @SpringBootApplication 을 찾은 후
해당 class 의 세팅을 그대로 Test class 에 옮겨준다.

```java
package hello.itemservice;

import hello.itemservice.config.*;
import hello.itemservice.repository.ItemRepository;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.Profile;

@Import(JdbcTemplateV3Config.class)
@SpringBootApplication(scanBasePackages = "hello.itemservice.web")
public class ItemServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(ItemServiceApplication.class, args);
	}

	@Bean
	@Profile("local")
	public TestDataInit testDataInit(ItemRepository itemRepository) {
		return new TestDataInit(itemRepository);
	}

}
```

이 경우 JdbcTemplateV3Config 를 import 하고있기 때문에 

```java
package hello.itemservice.config;

import hello.itemservice.repository.ItemRepository;
import hello.itemservice.repository.jdbcTemplate.JdbcTemplateItemRepositoryV3;
import hello.itemservice.service.ItemService;
import hello.itemservice.service.ItemServiceV1;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;

@Configuration
@RequiredArgsConstructor
public class JdbcTemplateV3Config {

    private final DataSource dataSource;

    @Bean
    public ItemService itemService() {
        return new ItemServiceV1(itemRepository());
    }

    @Bean
    public ItemRepository itemRepository() {
        return new JdbcTemplateItemRepositoryV3(dataSource);

    }
}
```

이 설정을 기반으로 Test 가 작동되게 된다.

### ✏️ Test 전용 DB

### 📍 필요성

앞에서 설명한대로 Test 를 실행할 경우 application 에서 실행했던 Data 들과 섞여버려 정확한 test 검증이 실패할 수 있다.

find all 을 예로들면 내가 Test 에서 등록한 Data 만 검증을 원했지만,
다른 Data 가 섞여버리면 결과가 실패로 나오고 정확한 검증을 할 수 없다.

그렇다고 Test 를 위해서 DB 를 비워버리면 DB 에 저장을 해뒀던 data 가 없어지게 되므로 문제가 발생할 수 있다.

```java
@Test
    void findItems() {
        //given
        Item item1 = new Item("itemA-1", 10000, 10);
        Item item2 = new Item("itemA-2", 20000, 20);
        Item item3 = new Item("itemB-1", 30000, 30);

        itemRepository.save(item1);
        itemRepository.save(item2);
        itemRepository.save(item3);

        //둘 다 없음 검증
        test(null, null, item1, item2, item3);
        test("", null, item1, item2, item3);
```

### 📍 Test 전용 DB 로 분리해서 문제 해결

**방법 1. Test 용 DB 를 따로 만들어 application.yml 에 접속 url 변경**

[🔗 H2 DB 생성하는 방법](https://github.com/choideakook/TIL/blob/main/Spring/0%20Spring%20TIL/Intellij%20프로젝트%20생성후%20기본%20세팅.md)

DB 를 생성하고 main Table 과 동일하게 생성해준다.

```sql
drop table if exists item CASCADE;
     create table item
     (
         id        bigint generated by default as identity,
         item_name varchar(10),
         price     integer,
         quantity  integer,
         primary key (id)
     );
```

❗main DB 와는 별도의 DB 에서 Test 를 실행했으므로 Test 가 정상적으로 작동하지만,
Test 용 Data 가 rollback 되지 않아서 같은 test 를 반복하면 실패하는 경우가 생긴다.